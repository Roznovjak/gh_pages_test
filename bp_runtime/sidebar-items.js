initSidebarItems({"constant":[["ACCOUNT_DERIVATION_PREFIX","A unique prefix for entropy when generating cross-chain account IDs."],["CALL_DISPATCH_MODULE_PREFIX","Call-dispatch module prefix."],["KUSAMA_CHAIN_ID","Bridge-with-Kusama instance id."],["MILLAU_CHAIN_ID","Bridge-with-Millau instance id."],["NO_INSTANCE_ID","Use this when something must be shared among all instances."],["POLKADOT_CHAIN_ID","Bridge-with-Polkadot instance id."],["RIALTO_CHAIN_ID","Bridge-with-Rialto instance id."],["ROCOCO_CHAIN_ID","Bridge-with-Rococo instance id."],["ROOT_ACCOUNT_DERIVATION_PREFIX","A unique prefix for entropy when generating a cross-chain account ID for the Root account."],["WOCOCO_CHAIN_ID","Bridge-with-Wococo instance id."]],"enum":[["SourceAccount","Type of accounts on the source chain."],["StorageProofError",""],["TransactionEra","Era of specific transaction."]],"fn":[["craft_valid_storage_proof","Return valid storage proof and state root."],["derive_account_id","Derive an account ID from a foreign account ID."],["derive_relayer_fund_account_id","Derive the account ID of the shared relayer fund account."],["storage_map_final_key_blake2_128concat","This is a copy of the `frame_support::storage::generator::StorageMap::storage_map_final_key` for `Blake2_128Concat` maps."],["storage_map_final_key_identity","This is a copy of the `frame_support::storage::generator::StorageMap::storage_map_final_key` for `Identity` maps."],["storage_map_final_key_twox64_concat",""],["storage_parameter_key","This is how a storage key of storage parameter (`parameter_types! { storage Param: bool = false; }`) is computed."],["storage_value_final_key","Returns the storage prefix for a specific pallet name and storage name."]],"mod":[["messages","Primitives that may be used by different message delivery and dispatch mechanisms."]],"struct":[["HeaderId","Generic header Id."],["PreComputedSize","Pre-computed size."],["StorageProofChecker","This struct is used to read storage values from a subset of a Merklized database. The “proof” is a subset of the nodes in the Merkle structure of the database, so that it provides authentication against a known Merkle root as well as the values in the database themselves."]],"trait":[["Chain","Minimal Substrate-based chain representation that may be used from no_std environment."],["Size","Anything that has size."]],"type":[["AccountIdOf","Account id type used by the chain."],["AccountPublicOf","Account public type used by the chain."],["BalanceOf","Balance type used by the chain."],["BlockNumberOf","Block number used by the chain."],["ChainId","Unique identifier of the chain."],["HashOf","Hash type used by the chain."],["HasherOf","Hasher type used by the chain."],["HeaderOf","Header type used by the chain."],["IndexOf","Transaction index type used by the chain."],["SignatureOf","Signature type used by the chain."],["TransactionEraOf","Transaction era used by the chain."]]});